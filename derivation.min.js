const input=document.getElementById("input"),button=document.getElementById("derive"),latexOutput=document.getElementById("latex"),variables=document.getElementsByClassName("variable");import Latex from"./latexRenderer/latex.js";let xi={},rho={},startingFormat,endingFormat,Queue=[];const numberDerivationsCap=50;let numberDerivations=0,ticks={rho_ticks:0,xi_ticks:0};function isValidName(name){if(name.startsWith("$"))return alert("You cannot start your variable name with a '$'."),!1;let invalidWords;return!["begin","if","set","while","val","+","-","/","=","*","||","&&","mod"].includes(name)||(alert(`You cannot name your variable '${name}', as it is an Impcore keyword.`),!1)}function addVariablesToEnv(){xi={},rho={},ticks={rho_ticks:0,xi_ticks:0};let environments={xi:xi,rho:rho};["rho","xi"].forEach(env=>{let variables=document.getElementById(env).value;variables=variables.replaceAll(" ",""),variables=variables.substring(1,variables.length-1);const maps=variables.split(",");maps.forEach(mapping=>{const fields=mapping.split("→"),name=fields[0],value=fields[1];environments[env][name]=parseInt(value)})}),console.log(xi),console.log(rho)}function addValuesToQueue(value){let index=0,beginIndexes=[];function queueHelper(input,string,beginAmount){for(;index<input.length;){const char=input[index];if("("==char)index++,queueHelper(input,"",null),null!=beginAmount&&beginAmount++;else if(")"==char||" "==char){if("begin"==string?(beginIndexes.push(Queue.length),beginAmount=0):null!=beginAmount&&""!=string&&beginAmount++,""!=string&&(Queue.push(string),string=""),null!=beginAmount&&")"==char&&(Queue[beginIndexes.pop()]=`$begin${beginAmount.toString()}`),index++,")"==char)return}else string+=char,index++}""!=string&&Queue.push(string)}queueHelper(value,"",null),Queue.reverse()}function derive(exp,execute){if(numberDerivations++,numberDerivations>50)throw new Error("Nested derivation is too deep.");if(!isNaN(exp))return LIT(parseInt(exp),execute);if(exp.startsWith("$begin"))return BEGIN(exp,execute);switch(exp){case"if":return IF(execute);case"set":return SET(execute);case"while":return _WHILE(execute,!0);case"&&":return PRIMITIVE("\\&\\&",execute,{name:"And",equation:(f,s)=>f&&s?1:0,eqString:"$v_1 \\textsc{ \\&\\& } $v_2 = $v_r"});case"||":return PRIMITIVE(exp,execute,{name:"Or",equation:(f,s)=>f||s?1:0,eqString:"$v_1 \\textsc{ || } $v_2 = $v_r"});case"mod":return PRIMITIVE(exp,execute,{name:"Mod",equation:(f,s)=>f%s,eqString:"-2^{31} \\leq $v_1 \\textsc{ mod } $v_2 < 2^{31}"});case"+":return PRIMITIVE(exp,execute,{name:"Add",equation:(f,s)=>f+s,eqString:"-2^{31} \\leq $v_1 + $v_2 < 2^{31}"});case"-":return PRIMITIVE(exp,execute,{name:"Sub",equation:(f,s)=>f-s,eqString:"-2^{31} \\leq $v_1 - $v_2 < 2^{31}"});case"/":return PRIMITIVE(exp,execute,{name:"Div",equation:(f,s)=>Math.floor(f/s),eqString:"-2^{31} \\leq $v_1 / $v_2 < 2^{31}"});case"*":return PRIMITIVE(exp,execute,{name:"Mult",equation:(f,s)=>f*s,eqString:"-2^{31} \\leq $v_1 * $v_2 < 2^{31}"});case"=":return PRIMITIVE(exp,execute,{name:"Eq",equation:(f,s)=>f==s?1:0,eqString:"$v_1 ?= $v_2"});case">":return PRIMITIVE(exp,execute,{name:"Gt",equation:(f,s)=>f>s?1:0,eqString:"$v_1 > $v_2 = $v_r"});case"<":return PRIMITIVE(exp,execute,{name:"Lt",equation:(f,s)=>f<s?1:0,eqString:"$v_1 < $v_2 = $v_r"});default:return VAR(exp,execute)}}function searchEnv(variable,env){for(const key in env)if(key==variable)return env[variable];return null}function findVarInfo(variable){let environments={rho:rho,xi:xi};for(const name in environments){let value=searchEnv(variable,environments[name]);if(null!=value)return{env:name,value:value}}throw new Error(`${variable} cannot be found in either xi or rho.`)}function LIT(number,execute){let derivation;return execute&&(derivation=Latex.LiteralLatex(number,ticks)),{syntax:`Literal(${number})`,value:number,derivation:derivation,impcore:[number]}}function VAR(name,execute){let variable=findVarInfo(name),derivation;console.log(ticks);const rhoTicks=Latex.ticks(ticks,"rho"),xiTicks=Latex.ticks(ticks,"xi");return execute&&("rho"==variable.env?derivation=Latex.VarLatex("FormalVar",name,`${name} \\in dom \\rho${rhoTicks}`,`$\\rho${rhoTicks}(${name})$`,ticks):"xi"==variable.env&&(derivation=Latex.VarLatex("GlobalVar",name,`${name} \\notin dom \\rho${rhoTicks} \\and ${name} \\in \\xi${xiTicks}`,`$\\xi${xiTicks}(${name})$`,ticks))),{syntax:`Var(${name})`,value:variable.value,derivation:derivation,name:name,impcore:[name]}}function IF(execute){let derivation,value;const beforeTicks=JSON.parse(JSON.stringify(ticks)),condition=derive(Queue.pop(),execute,ticks),trueCase=derive(Queue.pop(),0!=condition.value&&execute,ticks),falseCase=derive(Queue.pop(),0==condition.value&&execute,ticks),syntax=`If(${condition.syntax}, ${trueCase.syntax}, ${falseCase.syntax})`;let impcore;return(execute&&(0==condition.value?(value=falseCase.value,derivation=Latex.IfLatex("IfFalse",syntax,condition.derivation,`${condition.value} = 0`,falseCase.derivation,value,beforeTicks,ticks)):(value=trueCase.value,derivation=Latex.IfLatex("IfTrue",syntax,condition.derivation,`${condition.value} \\neq 0`,trueCase.derivation,value,beforeTicks,ticks))),{syntax:syntax,value:value,derivation:derivation,impcore:["if"].concat(condition.impcore).concat(trueCase.impcore).concat(falseCase.impcore)})}function SET(execute){let derivation;const beforeTicks=JSON.parse(JSON.stringify(ticks)),rhoTicks=Latex.ticks(beforeTicks,"rho"),xiTicks=Latex.ticks(beforeTicks,"xi"),variable=derive(Queue.pop(),execute,ticks),exp=derive(Queue.pop(),execute,ticks),env=findVarInfo(variable.name).env;if(execute){if("xi"==env){const scope=`${variable.name} \\notin dom \\rho${rhoTicks} \\and ${variable.name} \\in dom \\xi${xiTicks}`,conditions=scope+`\\and ${exp.derivation}`,mapping={index:0,map:`\\{${variable.name} \\mapsto ${exp.value}\\}`};derivation=Latex.SetLatex("GlobalAssign",conditions,exp,variable,mapping,beforeTicks,ticks)}else{const scope=`${variable.name} \\in dom \\rho${rhoTicks}`,conditions=scope+`\\and ${exp.derivation}`,mapping={index:1,map:`\\{${variable.name} \\mapsto ${exp.value}\\}`};derivation=Latex.SetLatex("FormalAssign",conditions,exp,variable,mapping,beforeTicks,ticks)}let environment;({rho:rho,xi:xi})[env][variable.name]=exp.value,ticks[`${env}_ticks`]++}return{syntax:`Set(${variable.syntax}, ${exp.syntax})`,value:exp.value,derivation:derivation,impcore:["set"].concat(variable.impcore).concat(exp.impcore)}}function BEGIN(exp,execute){const n_amnt=parseInt(exp.split("$begin")[1]),beforeTicks=JSON.parse(JSON.stringify(ticks));let value=0,exps_syntax="",derivation,expression,exps_derivations="",impcore=[exp];for(let i=0;i<n_amnt;i++)expression=derive(Queue.pop(),execute,ticks),exps_syntax+=expression.syntax+", ",exps_derivations+="  \\\\\\\\ "+expression.derivation,impcore=impcore.concat(expression.impcore);exps_syntax=exps_syntax.substring(0,exps_syntax.length-2);const syntax=`Begin(${exps_syntax})`;return execute&&(0==n_amnt?derivation=Latex.BeginLatex("EmptyBegin"," \\ ",syntax,0,beforeTicks,ticks):(value=expression.value,derivation=Latex.BeginLatex("Begin",exps_derivations,syntax,value,beforeTicks,ticks))),{syntax:syntax,value:value,derivation:derivation,impcore:impcore}}function PRIMITIVE(exp,execute,functionInfo){let derivation;const beforeTicks=JSON.parse(JSON.stringify(ticks)),first=derive(Queue.pop(),execute,ticks),second=derive(Queue.pop(),execute,ticks),result=functionInfo.equation(first.value,second.value),syntax=`Apply(${exp}, ${first.syntax}, ${second.syntax})`;let eqString=functionInfo.eqString.replace("$v_1",first.value).replace("$v_2",second.value);return execute&&("="==exp?0==result?(eqString=eqString.replace("?=","\\neq"),derivation=Latex.ApplyLatex("ApplyEqFalse",exp,first,second,eqString,syntax,result,beforeTicks,ticks)):(eqString=eqString.replace("?=","="),derivation=Latex.ApplyLatex("ApplyEqTrue",exp,first,second,eqString,syntax,result,beforeTicks,ticks)):derivation=Latex.ApplyLatex(`Apply${functionInfo.name}`,exp,first,second,eqString,syntax,result,beforeTicks,ticks)),{syntax:syntax,value:result,derivation:derivation,impcore:[exp].concat(first.impcore).concat(second.impcore)}}function _WHILE(execute,first){let derivation,expression;const beforeTicks=JSON.parse(JSON.stringify(ticks));let condition=derive(Queue.pop(),execute,ticks);const beforeQueue=Queue;if(execute)if(expression=derive(Queue.pop(),0!=condition.value,ticks),0==condition.value)derivation=Latex.WhileLatex("WhileEnd","",condition,expression,`${condition.value} = 0`,beforeTicks,ticks);else if(Queue=condition.impcore.concat(expression.impcore).reverse(),first)derivation=Latex.WhileLatex("WhileIterate",_WHILE(execute,ticks,!1).derivation,condition,expression,`${condition.value} \\neq 0`,beforeTicks,ticks);else{const afterTicks=JSON.parse(JSON.stringify(ticks));derivation=Latex.WhileLatex("WhileIterate",_WHILE(execute,ticks,!1).derivation,condition,expression,`${condition.value} \\neq 0`,beforeTicks,afterTicks)}else expression=derive(Queue.pop(),!1,ticks);return Queue=beforeQueue,{syntax:`While(${condition.syntax}, ${expression.syntax})`,value:0,derivation:derivation,impcore:["while"].concat(condition.impcore).concat(expression.impcore)}}window.onload=()=>{document.getElementById("output").style.display="none",fetch("format.json").then(response=>response.json()).then(result=>{startingFormat=result.startingFormat,endingFormat=result.endingFormat})},Array.prototype.forEach.call(variables,variableDiv=>{const variableInfo=variableDiv.getElementsByClassName("variable_info")[0],addVariable=variableDiv.getElementsByClassName("add_variable")[0],button=variableDiv.getElementsByTagName("button")[0],env=variableDiv.getAttribute("value"),nameField=variableDiv.querySelector("input[name='name']"),valueField=variableDiv.querySelector("input[name='value']");addVariable.addEventListener("click",()=>{"none"==variableInfo.style.display||""==variableInfo.style.display?variableInfo.style.display="flex":variableInfo.style.display="none"}),button.addEventListener("click",()=>{const name=nameField.value.replaceAll(" ",""),value=valueField.value;if(""==name||""==value)return void alert("Please fill in the name and the value of the variable");if(!isValidName(name))return;let currentValue=document.getElementById(env).value,addOn="";addOn=" {}"==currentValue?`${name} → ${value}}`:`, ${name} → ${value}}`,document.getElementById(env).value=currentValue.substring(0,currentValue.length-1)+addOn})}),button.addEventListener("click",()=>{numberDerivations=0;let value=input.value.toLowerCase();if(""!=value&&null!=value){addVariablesToEnv(),Queue=[],addValuesToQueue(value),console.log(Queue);try{const derivation=derive(Queue.pop(),!0);console.log("derivation is",derivation),latexOutput.innerText=startingFormat+derivation.derivation+endingFormat,window.location.href="#output",document.getElementById("output").style.display="block"}catch({name:name,message:message}){return console.log(message),void("Nested derivation is too deep."==message?alert("The derivation has over the max amount of layers (50)."):alert("Improper Impcore expression!"))}}else alert("Ill-formed Impcore expression")});